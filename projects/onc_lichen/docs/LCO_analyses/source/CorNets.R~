bin.sum=function(x){
	x[x!=0]<-1
	sum(x)
	}


#Partial Correlation

pcor=function(x,method='pearson'){
	R=cor(x,method=method)
	p=1/(1-R^2)
	
	}
x=array(rnorm(100),c(10,10))

#produce a correlation network
cor.net=function(x,alpha,lim){
  
  lim.n=colnames(x)[apply(x,2,sum)<lim]
  x=x[,apply(x,2,sum)>=lim]
  col.n=append(colnames(x),lim.n)
  
  I=nrow(x)
  x=dchisq(eed(cor(x),I),1)
  diag(x)=0
  x[x<qchisq((1-alpha),1)]<-0
  
  x=cbind(x,array(0,c(nrow(x),length(lim.n))))
  x=rbind(x,array(0,c(length(lim.n),ncol(x))))
  rownames(x)=colnames(x)=col.n
  
  return(x)
  	
}

cor.net=function(x,alpha,lim,method='pearson',p.adj=TRUE){
 
 lim.n=colnames(x)[apply(x,2,sum)<lim]
 x=x[,apply(x,2,sum)>=lim]
 col.n=append(colnames(x),lim.n)
 
 I=nrow(x)
 y=cor(x,method=method)
 x=dchisq(eed(y,I),1)
 diag(x)=0
 
 if (p.adj==TRUE){
 	
 	}
 
 y=cbind(y,array(0,c(nrow(y),length(lim.n))))
 y=rbind(y,array(0,c(length(lim.n),ncol(y))))
 rownames(y)=colnames(y)=col.n
 
 return(y)
 	
 	}

#Correlation Pairwise Test
kendall.pairs=function(x,alpha=0.05,p.adj=FALSE,adj.method='holm',raw=FALSE){

	p=array(0,c(ncol(x),ncol(x)))
	colnames(p)=rownames(p)=colnames(x)
	r=p
		
	for (i in seq(along=rownames(p))){
		for (j in seq(along=colnames(p))){
			if (i==j|i<j){}
			   else{
			if (sum(x[,i])==0|sum(x[,j])==0){}else{
				out=unlist(suppressWarnings(cor.test(x[,i],x[,j],method='kendall')))
      			p[i,j]=round(as.numeric(out[2]),7)
	     		r[i,j]=round(as.numeric(out[3]),7)
				}
				}	
			}
		}

	if (p.adj==TRUE){
		p=p[lower.tri(p)]
		p[apply(x,2,sum)>0]=p.adjust(p[apply(x,2,sum)>0])
		p=round(p,7)
		}else{p=p[lower.tri(p)]}
		
	out=r*0
	out[lower.tri(out)]=p
	p=out
	p=as.matrix(as.dist(p))
	r=as.matrix(as.dist(r))
	r.=r
	r.[p>alpha]=0	
	if (raw==TRUE){
	out=list(r,p)	
		}
	else{
		out=r.
		}
				
	return(out)
	
}

#Distance based calculation of correlations
my.solve=function (a, b, tol = 1e-07) 
{
    if (!is.qr(a)) 
        a <- qr(a, tol = tol)
    nc <- ncol(a$qr)
    nr <- nrow(a$qr)
    if (a$rank != min(nc, nr)){
    	out="singular matrix 'a' in solve"
    	} 
    if (missing(b)) {
        if (nc != nr) 
            out="only square matrices can be inverted"
        b <- diag(1, nc)
    }else{
    out <- qr.coef(a, b)
    out[is.na(out)] <- 0	
    	}
    out
}

dcor.net=function(x,alpha=0.05,by.lim=0.01,max.lim=1,rm.spp=TRUE){
si.=x
si.p='si.p'
si.c=0
lim=0

lim=lim+by.lim
si.=si.[,apply(si.,2,sum)>lim]
si.d=vegdist(t(si.))
si.d=as.matrix(si.d)
si.c=gower(si.d)
si.p=my.solve(si.c)

while(any(si.p=="singular matrix 'a' in solve")){
lim=lim+by.lim
si.=si.[,apply(si.,2,sum)>lim]
si.d=vegdist(t(si.))
si.d=as.matrix(si.d)
si.c=gower(si.d)
si.p=my.solve(si.c)
if (lim>=max.lim){stop('ERROR: Singular matrix')}
}

si.p=solve(si.c)

print(lim)
print(si.p)

si.r=si.p*0

for (i in seq(1:nrow(si.p))){
	for (j in seq(1:ncol(si.p))){
	si.r[i,j]=(-si.p[i,j])/sqrt((si.p[i,i]*si.p[j,j]))
		}
	}

si.R=si.r*-1
diag(si.R)=1

si.eed=eed(si.R,nrow(x))
si.R[si.eed<qchisq((1-alpha),1)]<-0

if (rm.spp==TRUE){
rm.spp=colnames(x)[apply(x,2,sum)<=lim]
si.R=cbind(si.R,array(0.0000000,c(nrow(si.R),length(rm.spp))))
si.R=rbind(si.R,array(0.0000000,c(length(rm.spp),ncol(si.R))))
colnames(si.R)=rownames(si.R)=c(colnames(si.R)[1:(ncol(si.R)-length(rm.spp))],rm.spp)
	}else{}

return(si.R)
	}
	
#Given a list of adjacency matrixes, return the average of all edge weights
edge.mean=function(x){
	y=x[[1]]*0
	for (i in (1:length(x))){
		y=y+x[[i]]
		}
	y=y/length(y)
	return(y)
	}

#Kullback's chi-square test statistic for the difference between two correlation matrixes

chi.cor=function(x1,x2,n1,n2){
n=c(n1,n2)
Nk=n-1
N=sum(Nk)
Rk=list(x1,x2)
R=Rk[[1]]*0
for (i in (1:length(Rk))){
	R=R+(Nk[i]*Rk[[i]])
	}
R=R/N
Chi2.k=0
for (i in (1:length(Rk))){
	Chi2.k=Chi.k+(Nk[i]*log((det(R)/det(Rk[[i]]))))
	}
Chi2.df=((length(Rk)-1)*ncol(R)*(ncol(R)-1))/2	
p.val=pchisq(Chi2.k,Chi2.df,lower.tail=FALSE)
return(c(Chi2.df,Chi2.k,p.val))
}


#PermCor: permutes two input matrixes from a list
PermCor=function(x){
	x1=x[[1]]
	x2=x[[2]]
	x.=c(x1[lower.tri(x1)],x2[lower.tri(x2)])
	perm=sample(1:length(x.))
	x1.=array(dim=dim(x1))
	x2.=array(dim=dim(x2))
	x1.[lower.tri(x1.)]=x.[perm[(1:(length(x.)/2))]]
	x2.[lower.tri(x2.)]=x.[perm[(((length(x.)/2)+1):length(x.))]]
	x1.=as.matrix(as.dist(x1.))
	x2.=as.matrix(as.dist(x2.))
	colnames(x1.)=colnames(x2.)=rownames(x1.)=rownames(x2.)=colnames(x1)
	perm=list(x1.,x2.)
	names(perm)=names(x)[1:2]
	return(perm)
}

#Shared number of connections between networks, all graphs assumed to be undirected
shared=function(x,diag=FALSE){
if (diag==FALSE){
	for (i in (1:length(x))){diag(x[[i]])=0}}
for (i in (1:length(x))){x[[i]][x[[i]]!=0]=1}
for (i in (2:length(x))){x[[1]]=x[[1]]+x[[i]]}
x=x[[1]]
return(table(x[upper.tri(x)]))
}

#rm.isolated

rm.isolated=function(x){
	y=x
	x[x!=0]=1
	y=y[apply(x,1,sum)>=1,]
	y=y[,apply(x,2,sum)>=1]
	return(y)
}

#fragmentation (Begotti's )
fragmentation=function(x){
	require('igraph',quietly=TRUE)
	N=nrow(x)
	x=graph.adjacency(x,weighted=TRUE,mode='undirected')
	Nj=clusters(x)$csize
	F=1-(sum(Nj*(Nj-1))/(N*(N-1)))
	detach(package:igraph)
	return(F)
}


	
	
